INSTALLATION OF GeNN:

(i) Unpack GeNN.zip in a convenient location.

(ii) Define the environment variable "GeNNPATH" to point to the main GeNN 
     directory, e.g. if you extracted GeNN to /usr/local/GeNN, then you can add
     "export GeNNPATH=/usr/local/GeNN" to your login script. If you are using CYGWIN,
     the path should be a windows path or a mixed path (i.e. with normal slashes
     instead of backslashes) as it will be interpreted by cl.

(iii) Add $GeNNPATH/lib/bin to your PATH variable, e.g.
      "export PATH=$PATH:$GeNNPATH/lib/bin". Under CYGWIN, it is safer to enter full 
      linux path (such as: export PATH=$PATH:/usr/local/GeNN/lib/bin) 

(iv) Get a fresh installation of the Nvidia cuda toolkit from
     https://developer.nvidia.com/cuda-downloads

(v) Set the CUDA_PATH variable in $GeNNPATH/lib/include/makefile_common.mk to
    the location of your Nvidia cuda toolkit installation, if it is not already
    set by the system.
    For most people, the default value of /usr/local/cuda is fine.

(vi) Modify Makefile examples under $GeNNPATH/lib/src/ and $GeNNPATH/userproject/
     to add extra linker, include and compiler flags on a per-project basis, or
     modify global default flags in $GeNNPATH/lib/include/makefile_common.mk.

This completes the installation.

If you are using GeNN under CYGWIN with cl, you have to source vscvsrs.bat script under Visual Studio directory first.
Note that the debugging option is not available under CYGWIN.

------

HOW TO USE GeNN: 

For a first complete test, the system is best used with a full driver program such as
 
tools/generate_run [CPU/GPU] [nAL] [nKC] [nLH] [nDN] [gscale] [DIR] [EXE] [MODEL] [DEBUG OFF/ON]. 

In order to get a quick start and run the provided example model, go to GeNN/tools

type "make"

To use it, navigate to the "userproject/MBody1_project" directory and type
"../../tools/generate_run 1 100 1000 20 100 0.00117 outname classol_sim MBody1 0" 
which would generate a model of the locust olfactory system. 
The tool generate_run will generate connectivity files for the model
MBody1, compile and run it on the GPU, with 100 antennal lobe neurons, 1000 mushroom body Kenyon cells, 
20 lateral horn interneurons and 100 mushroom body output neurons. All output files 
will be prefixed with "outname" and will be created under the "outname" directory.

Alternatively, navigate to the "userproject/Poisson-Izh_project" directory and type
"../../tools/generate_run 1 100 1000 20 100 0.002 TestOutdir PoissonIzh_sim Poisson-Izh 0"
for a simpler two population model with 100 poisson input 1000 Izhikevich phasic bursting output
network. In this case, args defining other populations will be discarded.

In more details, what generate_run program does is: 
a) use some other tools to generate the appropriate connectivity
matrices and store them in files.

b) build the source code for the model by writing neuron numbers into
userproject/include/sizes.h, and executing "buildmodel MBody1 [DEBUG OFF/ON]".  

c) compile the generated code by invoking "make clean && make" 
running the code, e.g. "linux/release/classol_sim r1 1".

This is already a quite highly integrated example. If one was to use
the library for GPU code generation only, the following would be done:

a) The model in question is defined in a file, say "Model1.cc".  

b) this file needs to 
  (i) define "DT" 
  (ii) include "modelSpec.h" and "modelSpec.cc"
  (iii) contains the model's definition in the form of a function 
  "void modelDefinition(NNmodel &model)" 
  ("MBody1.cc") shows a typical example)

c) The programmer defines his/her own modeling code along similar lines as
"map_classol.*" together with "classol_sim.*". In this code, 

- she defines the connectivity matrices between neuron groups. (In the
example here those are read from files).  

- she defines input patterns (e.g. for Poisson neurons like in the
example) 

- she uses "stepTimeGPU(x, y, z);" to run one time step on the GPU or
"stepTimeCPU(x, y, z);" to run one on the CPU. (both versions are
always compiled). However, mixing the two does not make too much
sense. The host version uses the same memory whereto results from the
GPU version are copied (see next point) 

- she uses functions like "copyStateFromDevice();" etc to obtain
results from GPU calculations.

- the simulation code is then produced in two steps:
"buildmodel Model1 [DEBUG OFF/ON]" and
"make clean && make"

For a first minimal test, the system may be used with 

tools/generate_run_1comp [CPU/GPU] [n] [nKC] [DIR] [EXE] [MODEL] [DEBUG OFF/ON].

This would create a set of tonic spiking Izhikevich neurons with no connectivity, 
receiving an external sine wave current input. 
To use it, navigate to the "userproject/OneComp_project" directory and type
"../../tools/generate_run_1comp 1 1 Outdir OneComp_sim OneComp 0".
This would create one neuron receiving 5 nA oscillating input at 5 Hz. Input and output values 
are written under Outdir. 
-----

For more about this example model provided by generate_run see 

T. Nowotny, R. Huerta, H. D. I. Abarbanel, and M. I. Rabinovich Self-organization in the olfactory system: One shot odor recognition in insects, Biol Cyber, 93 (6): 436-446 (2005), doi:10.1007/s00422-005-0019-7 
